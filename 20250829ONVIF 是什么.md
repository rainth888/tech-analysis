下面是一份面向“做 IPC / NVR / 平台接入”的 **ONVIF 协议全景说明与落地指南**。尽量把你在工程落地时真正会用到的点都讲清楚。

---

# 1. ONVIF 是什么

* **定位**：安防视频行业的**互联互通标准**（组织名即 Open Network Video Interface Forum）。
* **目标**：不同厂商的摄像机、录像机、门禁等，**统一发现、配置、取流、事件与存储接口**，减少私有协议适配成本。
* **技术栈**：基于 **SOAP 1.2 + WSDL**（XML Web Service），运行在 **HTTP/HTTPS**；发现用 **WS-Discovery**；视频流本身走 **RTSP/RTP/UDP/TCP**。

> 重要：ONVIF**只规范控制与互通**（发现、配置、取流 URI、事件…），**不直接承载码流数据**；码流仍是 RTSP/RTP（H.264/H.265/MJPEG…）。

---

# 2. 核心“Profile”（使用场景打包）

把庞大的服务/能力“打包成最小集合”，叫 **Profile**。常见与图像相关的：

* **Profile S**：IP 视频**直播取流**、基础事件、PTZ；最常用（NVR/平台拉流）。
* **Profile G**：**边缘存储**（摄像机/录像机上的录制、搜索、回放）。
* **Profile T**：**高级视频**（H.265、宽动态、元数据叠加、运动检测事件等），可视为 S 的进化。
* **Profile M**：**元数据与分析**（对象检测、轨迹、事件语义等在标准通道上传递）。
* **Profile C / A / D**（门禁生态）：

  * C：门禁控制（点位、门状态、读卡器等）
  * A：门禁**配置**（凭证、访问规则）
  * D：**外设**（控制器 ↔ 读头/键盘等）

> 工程建议：**摄像机至少做 Profile S**；有 H.265/元数据则同步支持 **T/M**；NVR/平台做 **S + G + T** 更稳。

---

# 3. 服务分层与你会用到的接口

ONVIF 把功能切成多个“Service”，每个 Service 有一套 SOAP 接口（WSDL）。

* **Device Management**（设备管理）：
  `GetCapabilities`、`GetSystemDateAndTime`、网络/时间/NTP/用户、远程重启、日志等。
* **Media / Media2**（媒体）：
  **GetProfiles → GetStreamUri**（生成 RTSP URL）、设置编码器/分辨率/帧率、OSD 等。Media2 是更新版，支持多通道更清晰。
* **PTZ**：
  `GetPresets/SetPreset`、`ContinuousMove/RelativeMove/AbsoluteMove`、变倍/对焦/巡航。
* **Imaging**：
  亮度、对比度、曝光、白平衡、降噪等参数的读/写。
* **Events**：
  **主题树**（`GetEventProperties`）、**PullPoint 订阅**、拉取报警（运动检测、遮挡、断网恢复等）。
* **Analytics**：
  规则/区域设置、分析事件（与 Profile M 结合更系统）。
* **Recording / Replay / Search**（Profile G）：
  录制管理（`CreateRecording`）、搜索片段、生成**回放 URI**。
* **DeviceIO**：
  报警输入（DI）、报警输出（DO）、音频 I/O 等。

---

# 4. 典型工作流（平台/上位机）

1. **发现设备**（局域网）：
   WS-Discovery（UDP 239.255.255.250:3702）发送 `Probe`，设备 `ProbeMatch` 返回 `XAddrs`（服务地址）。
2. **查询能力**：
   `Device:GetCapabilities` → 得到 Media/PTZ/Events/Analytics 的服务 URL。
3. **时间同步**：
   `GetSystemDateAndTime`，必要时 `SetNTP`。

   > **强烈建议**时间同步：WS-Security 的时间戳校验、录像检索、事件均依赖时钟。
4. **认证**：

   * SOAP 接口：常用 **WS-Security UsernameToken**（Nonce + Created + PasswordDigest）。
   * RTSP 取流：HTTP Basic/Digest、或与设备账号一致。
5. **取流**：
   `Media:GetProfiles` → `Media:GetStreamUri`（得到 RTSP URL），用 RTP/RTSP 播放/解码。
6. **PTZ / 成像**：
   读取/设置参数、预置位、巡航等。
7. **事件**：
   `Events:CreatePullPointSubscription` → 周期 `PullMessages`，解析 Topic/Message（运动、遮挡、断线恢复…）。
8. **存储/回放（可选）**：
   对边缘录制：`Search:GetRecordingSummary`、`Replay:GetReplayUri` 生成回放流地址。

---

# 5. 安全与认证要点

* **WS-Security UsernameToken**（常见）：
  `PasswordDigest = Base64( SHA1( Nonce + Created + Password ) )`。
  → 需要设备/客户端时间一致（误差大就失败）。
* **HTTP(S)**：
  SOAP 通常走 `http(s)://.../onvif/device_service`；建议**启用 HTTPS**。
* **RTSP**：
  `rtsp://user:pass@ip:554/Streaming/Channels/101?transportmode=unicast`（示例）
* **用户/权限**：设备支持多用户，接口里有 `CreateUsers/SetUser`；留意管理/操作只读权限。

---

# 6. 端口与网络

* **发现**：UDP 3702（多播 239.255.255.250），对三层交换/NAT 环境要规划（跨网段常需手动添加设备或中继）。
* **控制**：HTTP/HTTPS（80/443 或厂家自定义）。
* **取流**：RTSP（默认 554），RTP 可能走 UDP（音视频多端口）或 TCP（interleaved）。
* **事件**：PullPoint 由客户端发起 HTTP 请求，NAT 友好；Push 需要可达回调地址。

---

# 7. 与编码/码流的关系

* Profile S/T **不限制你具体用哪种编码**，但会对能力有最低要求（如支持 H.264/H.265、帧率/分辨率可配置、元数据叠加等）。
* **元数据**（如人形框、运动矢量）可：

  * 叠加在 RTP 辅助流（KLV/专用负载）
  * 通过 **Events**/Profile M 的标准事件主题上报。

---

# 8. 合规与测试

* **Conformance**：实现对应 Profile 的\*\*所有必选（Mandatory）\*\*项；可选项按需。
* **官方测试工具**（Device Test Tool / Client Test Tool）：做一致性测试，生成报告。
* **厂商扩展**：允许带自家扩展命名空间，但**不得破坏**标准能力；注意与第三方兼容。

---

# 9. 工程落地清单（摄像机/平台两端）

**摄像机侧（Device）：**

* Profile S/T（最起码 S），实现：

  * WS-Discovery、Device、Media（GetProfiles/GetStreamUri）、Events PullPoint、PTZ（若有）、Imaging。
* 认证：支持 WS-Security UsernameToken、HTTPS。
* 时间：内置 NTP 客户端；上电后尽快同步；Digest 容差配置。
* 多网口/多地址：`GetNetworkInterfaces`/`SetNetworkDefaultGateway` 正确返回/配置。
* 码流：清晰的通道命名（主码流 101、副码流 102…）和稳定的 RTSP 路径。
* 事件：提供规范的 Topic（如 `tns1:MotionAlarm`），附带有用的 Source/Property。

**平台/NVR侧（Client）：**

* 发现不上来就**支持手工添加**（IP/端口/认证）。
* 先 `GetCapabilities`，按返回的地址分别调用各服务（不要硬编码路径）。
* 获取 **Media2** 优先（有就用），否则回退 Media。
* 事件拉取采用 PullPoint，设置合理超时与重连策略。
* RTSP 尝试 UDP→TCP 回退，超时/丢包容错；支持 `rtsp over http`（穿透代理）。
* 统一做 **时间差校准**（发请求前 `GetSystemDateAndTime`）。
* 解析不同厂家**私有扩展**时，容错而不崩（忽略未知 XML 元素）。

---

# 10. 调试与常见坑

* **认证失败**：多半是时间漂移 → 设备/NVR 对齐 NTP。
* **Discovery 不到**：跨网段、VLAN、禁多播 → 手动添加或做 WS-Discovery 中继。
* **取流卡/断**：NAT/丢包 → 试 RTSP over TCP；检查 MTU；关闭 UDP 打洞。
* **多通道/多传感器**：Media2 的轨道描述更清晰；老设备用 Media 需要遍历 `VideoSourceConfiguration`。
* **事件“收不到”**：PullPoint 轮询超时时间过短/过长、Topic 过滤不当；先 `GetEventProperties` 看主题树。
* **回放 URI 无法播**：Profile G 走 **Replay Service** 的 URI，不等于直播 URI；有时需平台端本地代理。

---

# 11. 代码示例（Python，快速拉 RTSP）

> 只做“控制层”，取流仍交给任何 RTSP 客户端（ffplay/ffmpeg/自研解码器）。

```python
# pip install onvif-zeep
from onvif import ONVIFCamera

ip, port = "192.168.1.100", 80
user, pwd = "admin", "password"

cam = ONVIFCamera(ip, port, user, pwd, wsdl_dir="/path/to/wsdl")  # wsdl_dir 可用库自带的
dev = cam.create_devicemgmt_service()
media = cam.create_media_service()  # Media2: cam.create_media2_service()

# 能力/时间
caps = dev.GetCapabilities({'Category':'All'})
time = dev.GetSystemDateAndTime()

# 获取 profile & RTSP
profiles = media.GetProfiles()
token = profiles[0].token
uri = media.GetStreamUri({
    'StreamSetup': {'Stream': 'RTP-Unicast', 'Transport': {'Protocol': 'RTSP'}},
    'ProfileToken': token
}).Uri

print("RTSP:", uri)
# 用 ffplay 测试： ffplay "<打印出来的 RTSP 地址>"
```

---

# 12. 你可能会用到的工具/库

* **python-onvif / onvif-zeep**（Python）
* **gSOAP**（C/C++）
* 抓包：**Wireshark**（有 ONVIF/RTSP 解析器）
* 命令行测试：`ffplay/ffmpeg`、`curl`（SOAP 也可手写 XML 调）
* 官方：**ONVIF Conformance Test Tool**（需要会员/授权）

---

## 小结

* 把 ONVIF 理解为“**SOAP 控制 + RTSP 取流**”的组合即可。
* **Profile S/T/G/M** 覆盖大多数摄像头/录像场景；
* 工程落地的关键：**时间同步、认证、发现/能力分发、事件 PullPoint、RTSP 容错**。
* 先按本文清单做“最小互通”，再逐步加高级功能（元数据/边缘存储/智能分析）。


# ***************************************************************

我现在这边不能直接上网抓 GitHub 的最新星标数据，但基于常见度与社区口碑（截至 2024 年前后）的“高星/活跃度较好”的 ONVIF 开源项目，我给你做了一份跨语言清单，并附快速选型建议。你可以用它们的名称直接上 GitHub 搜一下最新 Star/最近提交时间来核实。

# ONVIF 开源项目清单（按语言）

| 语言          | 仓库（关键词）                                                  | 类型/定位               | 亮点与备注（口碑向）                                                                       | 典型场景                          |
| ----------- | -------------------------------------------------------- | ------------------- | -------------------------------------------------------------------------------- | ----------------------------- |
| **C/C++**   | **gsoap/gsoap**（仓库里有 `samples/onvif`）                    | SOAP 工具包 + ONVIF 样例 | Star 很高；工业界常用；设备侧（摄像机/NVR）实现 ONVIF 的“硬核选项”。支持从 WSDL 生成代码，样例覆盖 Device/Media/PTZ 等 | **设备端（实现 ONVIF 服务器）** 或高性能客户端 |
| **Node.js** | **agsh/onvif**                                           | 客户端库                | 社区使用广、示例多，支持发现、Media、PTZ、Events；对 Node/前后端融合的项目友好                                | **平台/客户端接入**、快速 PoC           |
| **Node.js** | **futomi/node-onvif**                                    | 客户端库                | 另一热门实现，API 简洁，文档清晰；与上面二选一即可                                                      | 平台/工具脚本                       |
| **Python**  | **home-assistant-libs/pyonvif**（也叫 pyonvif / onvif-zeep） | 客户端库                | 基于 **zeep** 的 SOAP 客户端封装，Home Assistant 社区在用，维护较稳                                | **平台/中台**、批量设备管理、测试脚本         |
| **Go**      | **use-go/onvif**（或 **goonvif** 关键字）                      | 客户端库                | Go 生态里最常见；便于并发/微服务；发现、Media、PTZ 常用接口齐全                                           | 网关/边缘服务、NVR 平台                |
| **C**       | **Kurokesu/libonvif**                                    | 轻量客户端               | 体积小、容易嵌入；做设备批量探测/拉流 URI 查询很合适                                                    | 设备批量管理、探测器                    |
| **Rust**    | **lumeohq/onvif-rs**                                     | 协议模型/客户端            | 现代语言实现，类型安全；对稳定性要求高的新项目可评估                                                       | 新项目/网关服务（Rust 技栈）             |
| **NVR 应用**  | **scottlamb/moonfire-nvr**                               | NVR 应用（支持 ONVIF）    | Star 高、性能好；虽不是纯库，但学习其 ONVIF 发现/取流集成很有价值                                          | 参考实现/自建 NVR                   |

> 说明：名称就是 GitHub 的 `org/repo` 关键词，直接搜索即可。Node 的 **agsh/onvif** 与 **futomi/node-onvif** 都挺常用；Python 侧优先看 **pyonvif**；C/C++ 设备侧实现优先看 **gsoap** 的 ONVIF 样例。

---

## 选型建议（一句话版）

* **要做“摄像机/设备端”实现 ONVIF**：直接上 **gSOAP（gsoap/gsoap）** 的 ONVIF 样例，按需裁剪 Device/Media/Events/PTZ。
* **要做“平台/NVR/客户端”接入**：

  * Python 项目：**pyonvif（onvif/pyonvif/pyonvif-zeep）**
  * Node 项目：**agsh/onvif** 或 **futomi/node-onvif**
  * Go 项目：**use-go/onvif（goonvif）**
* **嵌入式体积敏感的探测/拉流 URI**：试 **Kurokesu/libonvif**。
* **想看成熟集成范例**：读 **moonfire-nvr** 的 ONVIF 模块做法（发现→能力→取流）。

---

## GitHub 搜索小技巧（复制到 GitHub 搜索栏）

* 高星 Node 客户端：`onvif language:JavaScript stars:>300`
* 高星 Python 客户端：`onvif language:Python stars:>200`
* 设备侧 C/C++：`onvif gsoap language:C++`
* Go 生态：`onvif language:Go`
* 近期活跃：在搜索后点 **Sort → Recently updated** 对比近三个月提交。

---

## 快速连通性示例

**Python（pyonvif/zeep）：**

```python
# pip install onvif-zeep
from onvif import ONVIFCamera
cam = ONVIFCamera("192.168.1.10", 80, "admin", "password")
media = cam.create_media_service()
prof = media.GetProfiles()[0]
uri = media.GetStreamUri({
  'StreamSetup': {'Stream':'RTP-Unicast','Transport':{'Protocol':'RTSP'}},
  'ProfileToken': prof.token
}).Uri
print(uri)  # 拿到 RTSP 地址后用 ffplay/ffmpeg 播放
```

**Node（agsh/onvif）：**

```js
// npm i onvif
const { Cam } = require('onvif');
new Cam({hostname:'192.168.1.10', username:'admin', password:'password'}, function(err) {
  if (err) return console.error(err);
  this.getStreamUri({ protocol:'RTSP' }, (e, r) => console.log(r.uri));
});
```

---

想让我帮你“带着条件筛选”（比如：**支持 Media2、维护活跃 <90 天、Stars > 300、某语言**）也没问题——把你的偏好告诉我，我给你列一个更精确的候选清单，并附上各项目的近期活跃度与选择理由。

